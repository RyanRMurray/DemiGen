\documentclass{article}
\usepackage{array, tabularx}
\usepackage{cellspace}
\usepackage{appendix}

\begin{document}
\thispagestyle{plain}
\begin{center}
    \Large
    \textbf{DemiGen: Procedurally Generating Content for Dungeons \& Dragons}
 
    \vspace{0.4cm}
    \large
    Progress Report
 
    \vspace{0.4cm}
    \textbf{By Ryan Murray}

    \vspace{0.4cm}
    \large
    Supervised by Michael Gale
\end{center}

\section{Project Overview}

With the continued success of Tabletop Roleplaying Games (TTRPGs) comes the increasing desire to streamline the more complex minutae that is required for these games to be played. One component that is required for most games and styles of play is a defined 'map' of the world the game takes place in. Maps in this case refers to physical locations in the game's setting, such as a building, town, dungeon, ect. \textit{Dungeons \& Dragons} for example makes much use of distance, cover and areas of effect that are best resolved using a concretely defined map. Considering the physical space one's character occupies and using terrain to one's advantage is often a satisfying experience. While there is a vast library of freely available pre-made maps online, it may be difficult for a Game Master (GM) to find one that perfectly meets their requirements. They may require one or more specific kinds of locations, or a certain number of encounters. Generally, the solution is for a GM to create their own worlds, which requires consideration of minute details such as the layout of each individual room in a map consisting of dozens of rooms. This can often be challenging for new GMs, who often resort to empty, flat rooms that are quick to design but does not allow for more tactical approaches to combat. 



While there are a few free solutions available online for generating dungeon spaces, it was found that the dungeons they generated were often uninteresting, relying on either plain rectangular rooms connected by corridors, or predictably spaced entrance points that place a limit on the potential layouts of a space.



The aim of this project is to produce software that would enable beginner GMs to generate maps that suit their needs. It consists of a few layers that each generate a certain element of the map; the order rooms are connected in, what rooms appear, and what appears in those rooms. A more thorough specification can be found in Appendix A.



The main problem that this project aims to tackle is the difficulty in producing 'interesting' terrain through procedural generation. The freely available solutions online produce predictably structured levels as they make use of simple algorithms. By investigating more novel forms of procedural generation, this project may produce higher quality maps. 


\section{Preliminary Research on Procedural Terrain Generation}
Much of the research that has been done into producing randomly generated terrain has been focused on its application in the development of video games. Also present in the research is attempts to define the layouts of man-made structures by a set of rules that can be implemented by an algorithm. 



Of particular note is the implementation of terrain generation in the \textit{Roguelike} genre of video games. Many of these games draw inspiration from TTRPGs themselves, and as such try to emulate a subset of the common gameplay loops found in such games. Generally, they focus on avoiding or fighting various types of enemies to attain better equipment and resources to take on greater challenges for greater rewards. As such, much of the focus is on the interaction between players and enemies, and various ways of finding and using loot. Older roguelikes often made use of algorithms that'd generate either a series of rectangular rooms or irregularly shaped cave-like networks. Modern games often make use of pre-fabricated modular rooms that are connected together by some criteria (such as specification of a certain number of rooms, or the requirement of special encounter rooms). \linebreak
While the former often resulted in inconsistent difficulty spikes due to a lack of loot or high concentration of enemies, the latter sacrifices the range of possible layouts of maps for more consistently balanced challenges. As a GM can fine-tune the challenge of an area on the fly, this project will consider more novel and open-ended terrain generation algorithms. As a result, the balance tradeoff in modern roguelikes is less useful. An implementation of such an algorithm would result in series of maps that reuse assets and as such may become stale and uninteresting for players.



The open-source project "WaveFunctionCollapse" on Github presents a novel algorithm for producing arbitrarily large images from small input patterns.\cite{wfc-report} By deducing a set of rules from an image (sub-pattern frequency, adjacency of patterns), the algorithm can produce cohesive images that contain frequencies of pixel patterns comparable to those of the input. However, this approach has a number of implementations that make it less suited for generating entire maps, particularly structured locations such as buildings or dungeons. In particular; the user would be required to specify much of the map's layout to guaruntee a minimum number of meaningful locations, and even then the total number of discrete locations can be unpredictable.



Valtchanov and Brown identified and demonstrated an algorithm for generating random dungeons using a genetic algorithm\cite{genetic}. By producing a set of trees in which nodes correspond to pre-fabricated rooms and edges the physical connections between them, then comparing them by a set of criteria, the algorithm produces dungeons that are well-connected and diverse. By adding extra criterias, it is possible to generate more interesting maps, such as ones in which discrete areas are connected by "special event" rooms. However, this runs into the aformentioned problem of prefabricated rooms becoming predictable and uninteresting.



A novel way of producing randomly generated structures was explored by Koning and Eizenberg using Shape Grammars.\cite{koning1981language} Like Context-Free Grammars, Shape Grammars rely on a set of rules defining what permutations can follow a given starting point. But instead of producing strings, they generate structures in multidimensional space. x and y demonstrate both 2d and 3d implementations. However, the implementation of arbitary shape grammars remains an unsolved problem, and the reverse engineering of appplicable shape grammars for dungeon generation would in itself be a large undertaking.

\section{Progress}

\subsection{Research}
A good deal of research was done in relation to both explored avenues of terrain generation, as well as a number of underlying methods that proved to be useful when developing the software in Haskell. Time permitting, more research should be done into what data structures would be most effective for the project. For example, particularly large bottlenecks are experienced in the \textit{TileGen} module of the software (see the \textit{TileGen} section below). While a number of systems have been developed produce results similar to those desired for this project, none of them exhibit any degree of user-friendliness. As such, the ease of use of this software has become a priority.

\subsection{TileGen}
The in-room content generation module of \textit{DemiGen} has reached functional completion. By implementing the Overlapping model described in both the WaveFunctionCollapse\cite{wfc-report} repository and an in-depth explaination of its principles\cite{wfc-article}, the terrain of a room (the content most immediately relevant to combat strategy) can be generated by a small input pattern.




This implementation relies on a number of data structures to represent the both the rules and the wavefunction as it is collapsed;
\begin{itemize}
    \item Wave - A mapping of cartesian coordinates to a set of integers, which are indexes representing tiles generated from the input.
    \item AdjacencyRules - A mapping of tile indexes and a given direction to a set of tile indexes. This set represents the valid neighours of the given tile in a specified direction.
    \item Collapsed - A mapping of coordinates to a singular tile index, which is eventually parsed to create the output image.
    \item EntropyHeap - A heap of tuples containing a coordinate and a given 'entropy' for that point, ordered by the lowest entropy. (See below).
\end{itemize}
The tileset and rules are parsed from input \textit{.png} images. This image is split and filtered to produce a set of unique squares of pixels of a given size. Also parsed at this time is the relative frequency of each tile. Then, those tiles are all compared against each other. If one tile has the same configuration of pixels given an offset by one in a given direction, it is considered a valid neighbour in that direction.



The starting wave is then generated using a set of coordinates, each of which is mapped to sets of the generated tile indexes. The only limitation on these input coordinates is that they form one contiguous shape. This input wave is then collapsed by the following steps;
\begin{itemize}
    \item The first coordinate is selected from the EntropyHeap. Entropy in this case refers to how much the possibility space for that point has been collapsed. This results in the points with the fewest valid options being picked first.
    \item This coordinate is assigned a valid tile from its tile index list using a random number generator weighted by each tile's relative frequency in the input image. The selected index is inserted into the Collapsed map.
    \item This tile is passed to a 'propagate' function, that iteratively collapses the possibility space of neighbouring tiles by filtering out invalid neighbours as dictated by the AdjacencyRules.
    \item Whenever a neighbour is not collapsed, the propagation halts for that path.
    \item Once no more tiles are collapsed, the partially collapsed wave is returned.
    \item The selected coordinate is deleted from the Wave to reduce the number of unnecessary collapse attempts.
    \item This process is repeated until the Wave is empty.
\end{itemize}



Currently, the largest bottleneck in this module is in how the algorithm collapses the possibilities for each cell in the supplied grid. When a tile is placed in a cell, the adjacency rules are consulted to see what possible neighboring tiles are still valid. In turn, the remaining valid tiles in these neighbors are used to collapse the possibilites for their own neighbors. When a cell experiences no collapse, this propagation halts for that branch. However, this results in many instances of valid sets of tiles being generated for tiles that end up not being collapsed. Profiling reveals that more than 60\% of execution time happens in these functions. 



Once the functionality of the rest of the software has been complete, a series of example input patterns will be generated. Example patterns should include; a lightly furnished room, a room laden with traps, a room in which debris has accumulated \footnote{represented as \textit{difficult terrain} an environmental hazard that slows the movements of most players}. 

\subsection{TreeGen}
The overall dungeon structure algorithm (currently dubbed 'TreeGen') is yet to be implemented beyond a first draft of the data structures that will be used. The methods described by Valtchanov and Brown\cite{genetic} will be implemented, however the size of the outputs will be less of a priority than a more nuanced and extensive fitness function. Once again a number of data structures have been created to perform this task;
\begin{itemize}
    \item Room - a data structure containing a set of coordinates representing the shape of the room, relative to a (0,0) point in the top left. This structure also contains a smaller set of Doors, representing the potential openings this Room has to connect to other Rooms.
    \item RoomTree - a simple Tree data structure in which each node is 'labelled' with a type of Room, having any number of Children.
    \item Dungeon - a mapping of coordinates to Cells representing the dungeon generated from the RoomTree.
    \item Cell - a simple type indicating whether a coordinate in the Dungeon is occupied by a room or not.
\end{itemize}



In theory, a number of RoomTrees will be randomly generated from a set of input Rooms and a given number of maximum nodes. These RoomTrees will then be scored by the following metrics; \begin{itemize}
    \item How small the longest Path is - this should result in more compact, naturally structured dungeons
    \item How many of the rooms can viably be placed - this is tested by attempting to generate a Dungeon from the RoomTree. Should a Room fail to be placed (either by its parent not having an available Door or a lack of space), it and its subtree of Rooms will not be counted towards this metric. 
    \item The presence of a specified number of specified rooms.
\end{itemize}
The Genetic component of this algorithm will see the randomly generated trees pitted against eachother, with the lower-scoring trees being removed and the better trees being preserved and "crossed over". Crossover in this case referring to the swapping of a randomly selected subtree between pairs of "parent" trees. This new generation will then follow the same criteria, for a given number of generations. Finally, the highest scoring tree will be selected.

\subsection{Biomes and Structure}
A benefit of the genetic algorithm approach described above is the ability to potentially combine the specification's descriptions of biomes and overall dungeon structures into a single method. By supplying a different set of rooms and tweaking the fitness criteria, we can create easily differntiable subsections of a dungeon. Meeting the demands of the user would be a case of specifying a number of subsections and implementing the appropriate parameters.

\subsection{User Interface}
No progress has been made on the basis of user interface yet. The options presented to the user are to be decided at a later date when the capabilities of the \textit{TreeGen} module have been better explored. 


\pagebreak

\bibliographystyle{abbrv}
\bibliography{progress_report}

\pagebreak

\appendix
\section{Project Specification}

\begin{itemize}
    \item Create software that produces randomly generated quality maps of locations that can be used in \textit{Dungeons \& Dragons 5th Edition}
    \item Implement themes, specifying constraints and rules that generate maps that are identifiable as matching that theme
    \item Allow the user to impose constraints on the shape and content of the maps generated by the software
    \item Compare created software with freely available competing tools
\end{itemize}
\end{document}
